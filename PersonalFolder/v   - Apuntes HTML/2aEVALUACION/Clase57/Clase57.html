<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Clase 57</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='all' href='../resources/Css/main.css'>
    <link type="icon" rel="icon" href="../resources/icono.ico">
</head>

<body id="Page">
    <header>
        <h1>Clase 57</h1>
        <h3>Martes, 30 Enero 2024</h3>
    </header>
    <a href="../index2EVAL.html">Indice</a>

    <ul class="clase·List">
        <h4 class="remarks">Continuación de la clase 'Tree'</h4>
        <li>
            Creamos una función que encuentra un elemento entre los nodos hijos. Para ello utilizo un delegado, con los
            parámetros de búsqueda.
            <pre><code>
                '
                Node&ltT&gt findNode (DelegateChecker checker)
                '
            </code></pre>
        </li>
        <li>
            Definición completa de la función de búsqueda de un nodo
        </li>
        <li>
            Función 'Filter'
        </li>
        <li>
            Definición del delegado.
            <pre><code>
                '
                public delegate bool DelegateFilter(Node&ltT&gt);
                '
            </code></pre>
        </li>
        <li>
            Definición de la función 'Filter'
            <pre><code>
                '
                public void Filter(DelegateFilter filter)
                {
                    if(filter == null)
                    return;

                    for(int i = 0; i &lt list.Count; i++)
                    {
                        if(filter(list[i]))
                            listResult.Add(list[i]);
                    }
                }
                '
            </code></pre>
        </li>
        <li>
            Definición de la llamada a la función, mediante una función lambda.
            <pre><code>
                '
                Instancia i1 = new Instancia();
                i1.Filter(node => { return node.Name == "hijo";});
                '
            </code></pre>
        </li>
        <li>
            Podemos realizar código fuente utilizando patrones de programación, o respuestas establecidas para cada tipo
            de problema.
        </li>
        <li>
            Existen dos tipos de referencias a la hora de apuntar un objeto a la memoria RAM:
            <br>
            <i>strong references</i>: cada referencia aumenta el 'reference count'.
            <i>weak references</i>: las referencias no aumentan el 'reference count'.
        </li>
        <li>
            Los datos de tipo 'weak' no deberían ser los hijos, porque la ausencia de referencias hace que se elimine el
            objeto.
        </li>        
    </ul>
</body>

</html>