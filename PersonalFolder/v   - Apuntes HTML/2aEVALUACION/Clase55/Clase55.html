<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Clase 55</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='all' href='../resources/Css/main.css'>
    <link type="icon" rel="icon" href="../resources/icono.ico">
</head>

<body id="Page">
    <header>
        <h1>Clase 55</h1>
        <h3>Viernes, 26 Enero 2024</h3>
    </header>
    <a href="../index2EVAL.html">Indice</a>

    <ul class="clase·List">
        <h4 class="remarks">Repaso 'Heap' vs ' Stack</h4>
        <li>
            Un 'struct' permite mucha mayor cantidad de datos de fácil acceso. Además estos datos tienen una forma muy
            estructurada.
        </li>
        <li>
            Un 'struct' no tiene herencia ni interfaces
        </li>
    </ul>
    <ul class="clase·List">
        <h4 class="remarks">Garbage Collector</h4>
        <li>
            Cuando el elemento 'A' no tiene ningún puntero o referencia, el obejto se destruye.
        </li>
        <li>
            El runtime de C# no borra los elementos que se guardan en el 'Heap', sino que los mete en una lista de
            objetos 'muertos'
        </li>
        <li>
            Se trata de un comportamiento de 'Pull', donde los objetos desechados se guardan en una lista aparte, una
            minicaché de elementos muertos.
        </li>
        <li>
            Esta caché recibe el nombre de 'Garbage Collector'
        </li>
        <li>
            Aun asi, con una funcion que limpie el garbage collector, tampoco te aseguras que se destruya por completo
            el objeto.
        </li>
        <li>
            No puedes programar el destructor porque no sabes exactamente cuando se destruye el objeto.
        </li>
        <li>
            Garbage Collector es la lista de objetos muertos.
        </li>
        <li>
            El algoritmo 'LRU' o 'less recently used' elimina los elementos que mas tiempo llevo sin utilizar.
        </li>
    </ul>
    <ul class="clase·List">
        <h4 class="remarks">TREE</h4>
        <li>
            Contenedor de manera que un nodo es el principal o 'root', del cual crecen el resto de nodos de forma
            jerarquica descendiente.
        </li>
        <li>
            El primero es el nodo 'root'.
        </li>
        <li>
            Cada nodo tiene una lista de nodos, que son sus hijos o 'children'.
        </li>
        <li>
            Todos los children tienen el mismo 'root'
        </li>
        <li>
            Los atributos parent y children son privados. El padre del root es NULL.
        </li>
        <li>
            Los elementos nodos que no tienen hijos se llaman hojas o 'leaf'
        </li>
        <li>
            Las listas son privadas, nunca se devuelven.
        </li>
        <li>
            Level es la posición en la estructura del árbol.
        </li>
        <li>
            La función Remove es privada.
        </li>
    </ul>
</body>

</html>