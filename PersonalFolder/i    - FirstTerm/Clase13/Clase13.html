<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Clase 12</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='all' href='../resources/HTML/ClaseCss.css'>
    <link type="icon" rel="icon" href="../resources/icono.ico">
</head>

<body>
    <header>
        <h1>Clase 12</h1>
        <h3>Martes, 3 Octubre 2023</h3>
    </header>
    <a href="../index.html">Indice</a>

    <table>
        <tr>

            <!----------------- COLUMNA 1 ------------------->

            <td class="clase·Column">
                <ul class="clase·List" style="vertical-align: top;">

                    <h5 class="remarks">Función de búsqueda 'Binary Search'</h5>
                    <li>
                        Existe una función que nos devuelve un 'True/False' si cierto valor está dentro de una lista o array.
                        Esta función se llama 'Binary Search' y sólo funciona en caso que la lista/array esté ordenada
                    </li>
                    <li>
                        Funciona con Listas y Arrays ordenadas
                    </li>
                    <li>
                        El algoritmo es el siguiente:
                        <br>
                        1.- Buscamos la posición que se encuentra en la mitad de la lista.
                        <br>
                        2.- Comparo el valor de la posición media con el número que buscamos; Si concuerdan entonces el número <i>SI</i> está en la lista.
                        <br>
                        3.- Si el número que buscamos <i>es mayor</i> que el valor medio, entonces desplazo la posición mínima un entero por delante de la posición media.
                        <br>
                        4.- Si el número que buscamos <i>es menor</i> que el valor medio, entonces desplazo la posición máxima un entero por detrás de la posición media.
                        <br>
                        5.- Este algoritmo se repite hasta que el valor mínimo es mayor o igual que el valor máximo, o cuando se encuentra el número buscado.
                    </li>
                    <li>
                        Ejemplo de función que busca un valor de double dentro de una lista de doubles.
                        <pre><code>                    
                    '
                    <b>public static double BinarySearch(List&ltdouble&gt list, double number)</b>
                    {
                        if(list == null || list.Count == 0)
                        return false;

                        int minPosition = 0;
                        int maxPosition = list.Count - 1;
                        int midPosition;

                        while (minPosition &lt= maxPosition)
                        {
                            midPosition = (minPosition + maxPosition) / 2;

                            if (list[midPosition] == number)
                                return true;

                            if (number &gt list[midPosition])
                                minPosition = midPosition + 1;
                            else
                                maxPosition = midPosition - 1;
                        }
                        return false;
                    }                                                                        
                    '
                    </code></pre>
                    </li>
                    <li>
                        Ejemplo de función que busca un valor de double dentro de un array de doubles
                        <pre><code>                    
                    '
                    <b>public static double BinarySearch(double[] array, double number)</b>
                    {
                        if(list == null || list.Length == 0)
                        return false;

                        int minPosition = 0;
                        int maxPosition = list.Length - 1;
                        int midPosition;

                        while (minPosition &lt= maxPosition)
                        {
                            midPosition = (minPosition + maxPosition) / 2;

                            if (array[midPosition] == number)
                                return true;

                            if (number &gt array[midPosition])
                                minPosition = midPosition + 1;
                            else
                                maxPosition = midPosition - 1;
                        }
                        return false;
                    }                                                                        
                    '
                    </code></pre>
                    </li>
                </ul>
            </td>
    </table>

</body>

</html>